% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/run_update.R
\name{run_update}
\alias{run_update}
\title{FaaS - updating models in forecast pack generated by scale modeling}
\usage{
run_update(
  pack_list,
  date_variable,
  date_format,
  project_name,
  cv_update = FALSE,
  model_spec = list(),
  outlier_update = NULL,
  breakdown = NULL,
  base_dates = TRUE,
  save_local = NULL,
  ...
)
}
\arguments{
\item{pack_list}{list with information about all packs to be updated. For each pack a list with a \code{forecast_pack} and a \code{new_data} should be provided. See examples below.}

\item{date_variable}{name of variable with date information in all \code{new_data} in \code{pack_list}.}

\item{date_format}{format of \code{date_variable} in all \code{new_data} in \code{pack_list}.}

\item{project_name}{project name. A string with character and/or numeric inputs that should be at most 50 characters long. Special characters will be removed.}

\item{cv_update}{TRUE or FALSE, indicating whether cross validation should be ran again. Default: FALSE.}

\item{model_spec}{list containing: \code{fill_forecast}, \code{n_steps}, \code{n_windows} and \code{cv_summary}, see details for its description. All arguments are optional, however \code{n_steps}, \code{n_windows} and \code{cv_summary} should only be used when \code{cv_update = TRUE}. Default: list().}

\item{outlier_update}{TRUE or FALSE, indicating whether a new search for outliers should be conducted. Search for outliers will be done only when \code{cv_update} = TRUE. Default is TRUE when \code{cv_update} is TRUE, and FALSE otherwise.}

\item{breakdown}{TRUE, FALSE or vector with 'row_id' of models to run breakdown (max of 3 models). If \code{breakdown} is TRUE, model breakdown will be calculated for the first 3 arima models. If \code{breakdown} is FALSE, model breakdown from previous modeling will be removed from \code{forecast_pack}. Default is TRUE when \code{cv_update} is TRUE, and FALSE otherwise.}

\item{base_dates}{TRUE or FALSE, indicating whether initial date in modeling should be kept for update, if possible. Default: TRUE.}

\item{save_local}{[DEV ONLY] directory to save base64 with body that would be sent to the API. With this parameter the function will not send your modeling request to the API. Default: NULL.}

\item{...}{advanced parameters.}
}
\value{
Success or error message of API request.
}
\description{
Model update is a module that allows the user to update the models (in the \code{forecast_pack}) obtained using FaaS scale modeling, but using a \code{new_data}.
This means that the same specifications used initially will remain the same in the new updated \code{forecast_pack}. \cr
You can update one or more \code{forecast_pack}'s at a time, and you should also input a \code{new_data} for each forecast_pack.
The \code{new_data} should have all variables used in the original models, with the exact same names.
}
\details{
\itemize{
\item All models inside the provided \code{forecast_pack} will be updated, and their original order is maintained. However, if any model no longer converges, it will be removed from the outputted \code{forecast_pack}.
\item Model combinations will be updated only when all models used to compose the combination can be properly updated.
\item Some initial checks are performed in the files sent via \code{run_update} before the request is sent. If there is any inconsistency you will be informed in your R console.
\item All arguments in \code{model_spec} are optional. If left undefined, original specifications are retained from \code{forecast_pack}.
\item When \code{cv_update = FALSE}, the only argument passed in \code{model_spec} is \code{fill_forecast}. When \code{cv_update = TRUE} the other arguments are also allowed.
\item \code{model_spec}'s description:
\itemize{
  \item \code{fill_forecast}: if TRUE, it enables forecasting explanatory variables in order to avoid NAs in future values. Can be set to TRUE or FALSE.
  \item \code{n_steps}: forecast horizon that will be used in the cross-validation (if 3, 3 months ahead; if 12, 12 months ahead, etc.). \code{n_steps} should be an integer greater than or equal to 1. It is recommended that \code{n_steps}+\code{n_windows}-1 does not exceed 30\% of the length of your data.
  \item \code{n_windows}: how many windows the size of ‘Forecast Horizon’ will be evaluated during cross-validation (CV). \code{n_windows} should be an integer greater than or equal to 1. It is recommended that \code{n_steps}+\code{n_windows}-1 does not exceed 30\% of the length of your data.
  \item \code{cv_summary}:determines whether mean or median will be used to calculate the summary statistic of the accuracy measure over the CV windows. Can be set to 'mean' or 'median'.
}
}
}
\examples{
\dontrun{
 ## In order to run these examples, you will need to load your own forecast_pack's, which are
 ## the results of modeling run_models.

 ## EXAMPLE 1 - Updating one forecast_pack with cv_update = FALSE

 # Load dataset and forecast_pack
 # Load a data frame with our data
 dataset_1 <- readxl::read_excel("your_path/inputs/dataset_1.xlsx")

 # Load forecast_pack with models
 forecast_pack_1 <- readRDS("your_path/forecast_1_fs_pim.rds")

 # Put it inside a list and name the list with the elements' name
 pack1 <- list(forecast_pack = forecast_pack_1,
               new_data = dataset_1)

 # Put the list inside the pack_list
 pack_list_ex1 <-  list(pack1)

 # Also, specify the date variable and its format
 date_variable <- "DATE_VARIABLE"
 date_format <- '\%Y-\%m-\%d' # or'\%m/\%d/\%Y'

 # Set Project Name
 project_name <- "example_project"

 # Send request
 faas4i::run_update(pack_list = pack_list_ex1, date_variable = date_variable,
                    date_format = date_format, project_name = project_name,
                    cv_update = FALSE)

 ## EXAMPLE 2 - Using the same setup as example 1, but updating three forecast_packs at once

 # Load datasets and forecast_packs
 # Load data frames with our data
 dataset_1 <- readxl::read_excel("your_path/dataset_1.xlsx")
 dataset_2 <- readxl::read_excel("your_path/dataset_2.xlsx")
 dataset_3 <- readxl::read_excel("your_path/dataset_3.xlsx")

 # Load forecast_pack with models
 forecast_pack_1 <- readRDS("your_path/forecast_1_fs_pim.rds")
 forecast_pack_2 <- readRDS("your_path/forecast_2_fs_pmc.rds")
 forecast_pack_3 <- readRDS("your_path/forecast_3_fs_pib.rds")

 # Put each forecast pack and new dataset inside a list and name the
 # list with the elements' name
 pack1 <- list(forecast_pack = forecast_pack_1,
               new_data = dataset_1)
 pack2 <- list(forecast_pack = forecast_pack_2,
               new_data = dataset_2)
 pack3 <- list(forecast_pack = forecast_pack_3,
               new_data = dataset_3)

 # Put the list inside the pack_list
 pack_list_ex2 <-  list(pack1,
                        pack2,
                        pack3)

 # Also, specify the date variable and its format (must have the same name in all datasets)
 date_variable <- "DATE_VARIABLE"
 date_format <- '\%Y-\%m-\%d'

 # Send request
 faas4i::run_update(pack_list = pack_list_ex2, date_variable = date_variable,
                    date_format = date_format, project_name = project_name,
                    cv_update = FALSE)

 ## EXAMPLE 3 - Using the same setup as example 2, but allowing the accuracy measures
 ## to be updated by setting cv_update = TRUE, and also setting the full model_spec.
 ## Remember that all arguments in model_spec are optional.

 # Modeling settings
 model_spec <- list(fill_forecast = TRUE,
                    n_steps = 12,
                    n_windows = 12,
                    cv_summary = 'median')

 # Send request
 faas4i::run_update(pack_list = pack_list_ex2, date_variable = date_variable,
                    date_format = date_format, project_name = project_name,
                    cv_update = TRUE,
                    model_spec = model_spec)
}
}
\seealso{
\code{\link[httr]{POST}}
}
